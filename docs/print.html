<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solana Name Service Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="changelog.html"><strong aria-hidden="true">3.</strong> Changelog</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="registry.html"><strong aria-hidden="true">5.</strong> Name Registry</a></li><li class="chapter-item expanded "><a href="domain-name/index.html"><strong aria-hidden="true">6.</strong> Domain Name</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="domain-name/domain-tld.html"><strong aria-hidden="true">6.1.</strong> TLD</a></li><li class="chapter-item expanded "><a href="domain-name/domain-direct-lookup.html"><strong aria-hidden="true">6.2.</strong> Direct look up</a></li><li class="chapter-item expanded "><a href="domain-name/domain-reverse-lookup.html"><strong aria-hidden="true">6.3.</strong> Reverse look up</a></li><li class="chapter-item expanded "><a href="domain-name/subdomain-lookup.html"><strong aria-hidden="true">6.4.</strong> Subdomain look up</a></li><li class="chapter-item expanded "><a href="domain-name/domain-find-for-owner.html"><strong aria-hidden="true">6.5.</strong> Get all domains of a user</a></li><li class="chapter-item expanded "><a href="domain-name/favorite-domain.html"><strong aria-hidden="true">6.6.</strong> Favorite domain</a></li><li class="chapter-item expanded "><a href="domain-name/tokenization.html"><strong aria-hidden="true">6.7.</strong> Tokenization</a></li><li class="chapter-item expanded "><a href="domain-name/registration.html"><strong aria-hidden="true">6.8.</strong> Registration</a></li></ol></li><li class="chapter-item expanded "><a href="twitter/index.html"><strong aria-hidden="true">7.</strong> Twitter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="twitter/twitter-tld.html"><strong aria-hidden="true">7.1.</strong> TLD</a></li><li class="chapter-item expanded "><a href="twitter/register.html"><strong aria-hidden="true">7.2.</strong> Registration</a></li><li class="chapter-item expanded "><a href="twitter/twitter-direct-lookup.html"><strong aria-hidden="true">7.3.</strong> Direct look up</a></li><li class="chapter-item expanded "><a href="twitter/twitter-reverse-lookup.html"><strong aria-hidden="true">7.4.</strong> Reverse look up</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Solana Name Service Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./assets/introduction.gif" alt="introduction" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Solana Name Service (SNS). SNS has a simple mission of providing a decentralized and yet affordable way to map domain names (represented as .sol) to on-chain data. Where on-chain data can be anything from a Solana (SOL) address to IPFS CID, images, text, and more.
One of the clear benefits of the name service is a human-readable name that maps to a SOL address. Essentially, creating an identity for users in the metaverse.
Why does this matter you may ask? Well, wallet address formats can be a barrier to entry, and therefore having an identifiable address can facilitate payments and its efficiency.
Nonetheless, Solana domain names can have much broader applications than just payments. Most decentralized apps (dApps) have a single point of failure which is their centralized and censorable domain name. However, on-chain domain names cannot be censored or taken away! Thus a website hosted on IPFS (or Arweave) using a Solana domain name would be completely decentralized and very difficult to censor.</p>
<h2 id="twitter-handles--sol-domain-names"><a class="header" href="#twitter-handles--sol-domain-names">Twitter handles &amp; .sol domain names</a></h2>
<p>Both Twitter handles and .sol domain names are a part of SNS, yet are slightly different. A Twitter handle can only be claimed by the owner of the Twitter account. In order to guarantee this, the user needs to tweet the wallet address they want to associate with the account and then sign a transaction using the same wallet address. An oracle then verifies that the public key contained in the tweet matches with the signer. In practice, this means that Twitter names are already reserved. Twitter users just need to claim their public key by tweeting it.
Still, this has privacy implications that require you to have an identifiable Twitter account. This is where .sol domain names are useful. The domain names serve the same purpose as Twitter handles except they do not require you to reveal any personal information or a Twitter account.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The Solana Name Service program is deployed on Mainnet, Devnet and Testnet at the following address:</p>
<pre><code>namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX
</code></pre>
<p>To install the JS library</p>
<pre><code class="language-js">npm i @bonfida/spl-name-service
</code></pre>
<p>or</p>
<pre><code class="language-js">yarn add @bonfida/spl-name-service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<ul>
<li>In version <code>0.1.26</code> the signature of <code>NameRegistryState.retrieve</code> changed, it is now returning an object of type <code>{ registry: NameRegistryState, nftOwner: PublicKey | undefined }</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="where-can-i-buy-a-domain"><a class="header" href="#where-can-i-buy-a-domain">Where can I buy a domain?</a></h2>
<p>You can buy a domain on <a href="https://naming.bonfida.com">Bonfida</a></p>
<h2 id="how-do-i-find-a-domain-if-i-only-know-its-public-key"><a class="header" href="#how-do-i-find-a-domain-if-i-only-know-its-public-key">How do I find a domain if I only know its public key?</a></h2>
<p>If you only know the public key of a domain you can do a reverse look up to find the associated domain. For example:</p>
<pre><code class="language-js">import { performReverseLookup } from &quot;@bonfida/spl-name-service&quot;;

// Public key of bonfida.sol
const domainKey = new PublicKey(&quot;Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb&quot;);

const domainName = await performReverseLookup(connection, domainKey); // bonfida
</code></pre>
<h2 id="how-do-i-find-the-public-key-of-a-domain"><a class="header" href="#how-do-i-find-the-public-key-of-a-domain">How do I find the public key of a domain?</a></h2>
<p>If you want to find the public key of a domain you need to derive it:</p>
<pre><code class="language-js">import {
  getHashedName,
  getNameAccountKey,
  NameRegistryState,
} from &quot;@bonfida/spl-name-service&quot;;

const domainName = &quot;bonfida&quot;; // Without the .sol

// Step 1
const hashedName = await getHashedName(domainName);

// Step 2
const domainKey = await getNameAccountKey(
  hashedName,
  undefined,
  SOL_TLD_AUTHORITY
);
</code></pre>
<h2 id="how-can-i-find-the-content-of-a-domain"><a class="header" href="#how-can-i-find-the-content-of-a-domain">How can I find the content of a domain?</a></h2>
<p>You can access the content of a domain by retrieving its registry:</p>
<pre><code class="language-js">const { registry } = await NameRegistryState.retrieve(connection, domainKey);
const { parentName, owner, class, data } = registry;
</code></pre>
<h2 id="how-do-i-find-the-twitter-handle-of-a-public-key"><a class="header" href="#how-do-i-find-the-twitter-handle-of-a-public-key">How do I find the twitter handle of a public key?</a></h2>
<p>To find the twitter handle of a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from &quot;@bonfida/spl-name-service&quot;;

const pubkey = new PublicKey(&quot;FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ&quot;);

const [handle] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<h2 id="how-do-i-find-the-public-key-of-a-twitter-handle"><a class="header" href="#how-do-i-find-the-public-key-of-a-twitter-handle">How do I find the public key of a twitter handle?</a></h2>
<p>To find the public key of a twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from &quot;@bonfida/spl-name-service&quot;;

const handle = &quot;bonfida&quot;;

const registry = await getTwitterRegistry(connection, handle);
</code></pre>
<h2 id="how-do-i-find-all-the-subdomains-of-a-domain"><a class="header" href="#how-do-i-find-all-the-subdomains-of-a-domain">How do I find all the subdomains of a domain?</a></h2>
<p>You can find all the subdomains using the following RPC filter:</p>
<pre><code class="language-js">const filters = [
  {
    memcmp: {
      offset: 32,
      bytes: userAccount.toBase58(),
    },
  },
  {
    memcmp: {
      offset: 0,
      bytes: parent_key.toBase58(),
    },
  },
];
</code></pre>
<h2 id="how-do-i-find-all-the-subdomains-of-a-user"><a class="header" href="#how-do-i-find-all-the-subdomains-of-a-user">How do I find all the subdomains of a user?</a></h2>
<p>You can find all the subdomains of a user by doing the following</p>
<ol>
<li>Retrieve all the domains of the user</li>
<li>Iterate over the domains and retrieve the subdomains for each</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="name-registry"><a class="header" href="#name-registry">Name Registry</a></h1>
<p>The registry stores information about the domain name. It is made of two things:</p>
<ul>
<li>The header</li>
<li>The data</li>
</ul>
<p>The data for a domain name is always prefixed by the header, below is the structure of the header in both Rust and JS:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The layout of the remaining bytes in the account data are determined by the record `class`
#[derive(Clone, Debug, BorshSerialize, BorshDeserialize, PartialEq)]
pub struct NameRecordHeader {
    // Names are hierarchical.  `parent_name` contains the account address of the parent
    // name, or `Pubkey::default()` if no parent exists.
    pub parent_name: Pubkey,

    // The owner of this name
    pub owner: Pubkey,

    // The class of data this account represents (DNS record, twitter handle, SPL Token name/symbol, etc)
    //
    // If `Pubkey::default()` the data is unspecified.
    pub class: Pubkey,
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-js">export class NameRegistryState {
  parentName: PublicKey;
  owner: PublicKey;
  class: PublicKey;
  data: Buffer | undefined;

  static HEADER_LEN = 96;

  static schema: Schema = new Map([
    [
      NameRegistryState,
      {
        kind: &quot;struct&quot;,
        fields: [
          [&quot;parentName&quot;, [32]],
          [&quot;owner&quot;, [32]],
          [&quot;class&quot;, [32]],
        ],
      },
    ],
  ]);
  constructor(obj: {
    parentName: Uint8Array;
    owner: Uint8Array;
    class: Uint8Array;
  }) {
    this.parentName = new PublicKey(obj.parentName);
    this.owner = new PublicKey(obj.owner);
    this.class = new PublicKey(obj.class);
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain-names"><a class="header" href="#domain-names">Domain names</a></h1>
<p>This following sections provide information on the following:</p>
<ul>
<li><a href="domain-name/domain-tld.html">The domain names TLD</a></li>
<li><a href="domain-name/domain-direct-lookup.html">Direct look up</a></li>
<li><a href="domain-name/domain-reverse-lookup.html">Reverse look up</a></li>
<li><a href="domain-name/subdomain-lookup.html">Subdomain look up</a></li>
<li><a href="domain-name/domain-find-for-owner.html">Get all domains of a user</a></li>
<li><a href="domain-name/favorite-domain.html">Favorite domain</a></li>
<li><a href="domain-name/tokenization.html">Domain name tokenization</a></li>
<li><a href="domain-name/registration.html">Domain registration</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tld"><a class="header" href="#tld">TLD</a></h1>
<p>Top Level Domains (TLDs) are required to resolve domain names.</p>
<p>The <code>.sol</code> TLD is</p>
<pre><code class="language-js">export const SOL_TLD_AUTHORITY = new PublicKey(
  &quot;58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx&quot;
);
</code></pre>
<p>The <code>.sol</code> TLD is owned by the <code>root</code> TLD</p>
<pre><code class="language-js">export const ROOT_TLD_AUTHORITY = new PublicKey(
  &quot;ZoAhWEqTVqHVqupYmEanDobY7dee5YKbQox9BNASZzU&quot;
);
</code></pre>
<p>All <code>.sol</code> domains are subdomains of the <code>.sol</code> TLD</p>
<p><img src="domain-name/../assets/root-tld.png" alt="root-tld" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-look-up"><a class="header" href="#direct-look-up">Direct look up</a></h1>
<p>In order to get the information of a domain name you need to:</p>
<ol>
<li>Hash the domain name</li>
<li>Derive a PDA from the hash</li>
<li>Retrieve the account info</li>
</ol>
<pre><code class="language-js">import {
  getHashedName,
  getNameAccountKey,
  NameRegistryState,
} from &quot;@bonfida/spl-name-service&quot;;

const domainName = &quot;bonfida&quot;; // Without the .sol

// Step 1
const hashedName = await getHashedName(domainName);

// Step 2
const domainKey = await getNameAccountKey(
  hashedName,
  undefined,
  SOL_TLD_AUTHORITY
);

// Step 3
// The registry object contains all the info about the domain name (cf struct above)
// The NFT owner is of type PublicKey | undefined
const { registry, nftOwner } = await NameRegistryState.retrieve(
  connection,
  domainKey
);
</code></pre>
<p>The <code>retrieve</code> method returns an object made of two fields:</p>
<ul>
<li><code>registry</code> is of type <code>NameRegistryState</code></li>
<li><code>nftOwner</code> is of type <code>PublicKey | undefined</code>
<ul>
<li>When <code>nftOwner</code> is of type <code>PublicKey</code> it means that the domain is tokenized and the current NFT holder is <code>nftOwner</code>. When a domain is tokenized <code>registry.owner</code> is an escrow account that is program owner. Funds should be sent to <code>nftOwner</code></li>
<li>When <code>nftOwner</code> is of type <code>undefined</code> it means that the domain is not tokenized and funds should be sent to <code>registry.owner</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-look-up"><a class="header" href="#reverse-look-up">Reverse look up</a></h1>
<p>This can be used to resolve the domain name from its public key</p>
<pre><code class="language-js">import { performReverseLookup } from &quot;@bonfida/spl-name-service&quot;;

// Public key of bonfida.sol
const domainKey = new PublicKey(&quot;Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb&quot;);

const domainName = await performReverseLookup(connection, domainKey); // bonfida
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subdomain-look-up"><a class="header" href="#subdomain-look-up">Subdomain look up</a></h1>
<p>In order to resolve all subdomains of a parent domain:</p>
<pre><code class="language-js">import { findSubdomains } from &quot;@bonfida/spl-name-service&quot;;

// Public key of bonfida.sol
const parentKey = new PublicKey(&quot;Crf8hzfthWGbGbLTVCiqRqV5MVnbpHB1L9KQMd6gsinb&quot;);

// Assuming that bonfida.sol has the following subdomains
// - sub_1.bonfida.sol
// - sub_2.bonfida.sol

const subdomains: string[] = await findSubdomains(connection, parentKey); // [sub_1, sub_2]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-all-domains-of-a-user"><a class="header" href="#get-all-domains-of-a-user">Get all domains of a user</a></h1>
<p>You can retrieve all the domains owned by a public key using a <code>MemcmpFilter</code> filter</p>
<pre><code class="language-js">export async function findOwnedNameAccountsForUser(
  connection: Connection,
  userAccount: PublicKey
): Promise&lt;PublicKey[]&gt; {
  const filters = [
    {
      memcmp: {
        offset: 32,
        bytes: userAccount.toBase58(),
      },
    },
    {
      memcmp: {
        offset: 0,
        bytes: SOL_TLD_AUTHORITY.toBase58(),
      },
    },
  ];
  const accounts = await connection.getProgramAccounts(NAME_PROGRAM_ID, {
    filters,
  });
  return accounts.map((a) =&gt; a.pubkey);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="favorite-domain"><a class="header" href="#favorite-domain">Favorite domain</a></h1>
<p>Users have the possibility to select a domain name as their favorite one. You can retrieve it with the following</p>
<pre><code class="language-js">import { FavouriteDomain, NAME_OFFERS_ID } from &quot;@bonfida/name-offers&quot;;
import { performReverseLookup } from &quot;@bonfida/spl-name-service&quot;;
import { PublicKey } from &quot;@solana/web3.js&quot;;

const findFavoriteDomainName = async (owner: PublicKey) =&gt; {
  try {
    const [favKey] = await FavouriteDomain.getKey(
      NAME_OFFERS_ID,
      new PublicKey(owner)
    );

    const favourite = await FavouriteDomain.retrieve(connection, favKey);

    const reverse = await performReverseLookup(
      connection,
      favourite.nameAccount
    );

    return reverse;
  } catch (err) {
    console.log(err);
  }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokenization"><a class="header" href="#tokenization">Tokenization</a></h1>
<p>Domain names can be tokenized in NFTs that follow the metaplex standard.</p>
<p>To retrieve all the tokenized domain names</p>
<pre><code class="language-js">import { retrieveNfts } from &quot;@bonfida/spl-name-service&quot;;

// nfts is of type PublicKey[] and contains all the mints of the tokenized domain names
const nfts = await retrieveNfts(connection);
</code></pre>
<p>To retrieve the owner of the NFT that represent a tokenized domain name</p>
<pre><code class="language-js">import { retrieveNftOwner } from &quot;@bonfida/spl-name-service&quot;;

const owner = await retrieveNftOwner(connection, nameKey);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registration"><a class="header" href="#registration">Registration</a></h1>
<p>Registration instructions can be created either via SDK or API, both methods are equivalent. To register a domain you will have to specify the following:</p>
<ul>
<li>Domain names</li>
<li>Space (between 1kb and 10kb)</li>
<li>The public key of the buyer</li>
</ul>
<h2 id="sdk"><a class="header" href="#sdk">SDK</a></h2>
<p>Unregistered domains can be registered using the SDK <code>@bonfida/spl-name-service</code> with the following instructions:</p>
<pre><code class="language-js">import { registerDomainName } from &quot;@bonfida/spl-name-service&quot;;

const name = &quot;bonfida&quot;; // We want to register bonfida.sol
const space = 1 * 1_000; // We want a 1kB sized domain (max 10kB)

const buyer = new PublicKey(&quot;...&quot;); // Publickey of the buyer
const buyerTokenAccount = new PublicKey(&quot;...&quot;); // Publickey of the FIDA token account of the buyer

const [, ix] = await registerDomainName(name, space, buyer, buyerTokenAccount);

// sign and send the instruction
</code></pre>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>Registration instructions can also be created via API (equivalent to using the SDK):</p>
<pre><code>POST https://naming-api.bonfida.com/registrar/new-domain
</code></pre>
<p>With the following request body</p>
<pre><code class="language-json">{
  &quot;domain&quot;: &quot;domain_to_register&quot;,
  &quot;pubkey&quot;: &quot;pubkey_of_the_user&quot;,
  &quot;space&quot;: &quot;domain_space&quot;, // Between 1_000 and 10_000
  &quot;language&quot;: &quot;0&quot;
}
</code></pre>
<p>Response:</p>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;data&quot;: {
    &quot;keys&quot;: [
      {
        &quot;pubkey&quot;: &quot;SysvarRent111111111111111111111111111111111&quot;,
        &quot;isSigner&quot;: false,
        &quot;isWritable&quot;: false
      },
      // ...
      {
        &quot;pubkey&quot;: &quot;62pexKUPWncYECF7DMtENjKbwZnrJoMpvDkrrtceC8Ee&quot;,
        &quot;isSigner&quot;: false,
        &quot;isWritable&quot;: false
      }
    ],
    &quot;programId&quot;: &quot;jCebN34bUfdeUYJT13J1yG16XWQpt5PDx6Mse9GUqhR&quot;,
    &quot;data&quot;: [
      9,
      // ...
      0
    ]
  }
}
</code></pre>
<p>More details about direct registration can be found <a href="https://docs.bonfida.org/collection/how-to-create-a-solana-domain-name/purchasing-a-domain-name/direct-registration">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="twitter"><a class="header" href="#twitter">Twitter</a></h1>
<p>This following sections provide information on the following:</p>
<ul>
<li><a href="twitter/twitter-tld.html">The twitter TLD</a></li>
<li><a href="twitter/register.html">How to register a twitter handle</a></li>
<li><a href="twitter/twitter-direct-lookup.html">How to perform a direct look up</a></li>
<li><a href="twitter/twitter-reverse-lookup.html">How to perform a reverse look up</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tld-1"><a class="header" href="#tld-1">TLD</a></h1>
<p>The Twitter handle TLD is</p>
<pre><code class="language-js">export const TWITTER_ROOT_PARENT_REGISTRY_KEY = new PublicKey(
  &quot;4YcexoW3r78zz16J2aqmukBLRwGq6rAvWzJpkYAXqebv&quot;
);
</code></pre>
<p>The <code>.twitter</code> TLD is owned by the <code>root</code> TLD and all twitter handles are subdomains of the <code>.twitter</code> TLD</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="twitter-handle-registration"><a class="header" href="#twitter-handle-registration">Twitter handle registration</a></h1>
<p>Twitter handles can be registered <a href="https://naming.bonfida.org/twitter">here</a> and a detailed guide can be found <a href="https://docs.bonfida.org/collection/solana-name-service-twitter">on the Community Help Center</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="direct-look-up-1"><a class="header" href="#direct-look-up-1">Direct look up</a></h1>
<p>To find the Twitter handle associated to a public key</p>
<pre><code class="language-js">import { getHandleAndRegistryKey } from &quot;@bonfida/spl-name-service&quot;;

const pubkey = new PublicKey(&quot;FidaeBkZkvDqi1GXNEwB8uWmj9Ngx2HXSS5nyGRuVFcZ&quot;);

const [handle, registryKey] = await getHandleAndRegistryKey(connection, pubkey);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-look-up-1"><a class="header" href="#reverse-look-up-1">Reverse look up</a></h1>
<p>To find the public key associated to a Twitter handle</p>
<pre><code class="language-js">import { getTwitterRegistry } from &quot;@bonfida/spl-name-service&quot;;

const handle = &quot;bonfida&quot;;

const registry = await getTwitterRegistry(connection, handle);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
